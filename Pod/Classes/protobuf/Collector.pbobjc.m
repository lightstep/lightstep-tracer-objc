// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: collector.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/Timestamp.pbobjc.h>
#else
 #import "google/protobuf/Timestamp.pbobjc.h"
#endif

 #import "Collector.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"

#pragma mark - LTSCollectorRoot

@implementation LTSCollectorRoot

+ (GPBExtensionRegistry*)extensionRegistry {
  // This is called by +initialize so there is no need to worry
  // about thread safety and initialization of registry.
  static GPBExtensionRegistry* registry = nil;
  if (!registry) {
    GPBDebugCheckRuntimeVersion();
    registry = [[GPBExtensionRegistry alloc] init];
    [registry addExtensions:[GPBTimestampRoot extensionRegistry]];
  }
  return registry;
}

@end

#pragma mark - LTSCollectorRoot_FileDescriptor

static GPBFileDescriptor *LTSCollectorRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPBDebugCheckRuntimeVersion();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"lightstep.collector"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - LTSSpanContext

@implementation LTSSpanContext

@dynamic traceId;
@dynamic spanId;
@dynamic baggage, baggage_Count;

typedef struct LTSSpanContext__storage_ {
  uint32_t _has_storage_[1];
  NSMutableDictionary *baggage;
  uint64_t traceId;
  uint64_t spanId;
} LTSSpanContext__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "traceId",
        .dataTypeSpecific.className = NULL,
        .number = LTSSpanContext_FieldNumber_TraceId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LTSSpanContext__storage_, traceId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "spanId",
        .dataTypeSpecific.className = NULL,
        .number = LTSSpanContext_FieldNumber_SpanId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LTSSpanContext__storage_, spanId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "baggage",
        .dataTypeSpecific.className = NULL,
        .number = LTSSpanContext_FieldNumber_Baggage,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LTSSpanContext__storage_, baggage),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LTSSpanContext class]
                                     rootClass:[LTSCollectorRoot class]
                                          file:LTSCollectorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LTSSpanContext__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LTSKeyValue

@implementation LTSKeyValue

@dynamic valueOneOfCase;
@dynamic key;
@dynamic stringValue;
@dynamic intValue;
@dynamic doubleValue;
@dynamic boolValue;

typedef struct LTSKeyValue__storage_ {
  uint32_t _has_storage_[2];
  NSString *key;
  NSString *stringValue;
  int64_t intValue;
  double doubleValue;
} LTSKeyValue__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = LTSKeyValue_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LTSKeyValue__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "stringValue",
        .dataTypeSpecific.className = NULL,
        .number = LTSKeyValue_FieldNumber_StringValue,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(LTSKeyValue__storage_, stringValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "intValue",
        .dataTypeSpecific.className = NULL,
        .number = LTSKeyValue_FieldNumber_IntValue,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(LTSKeyValue__storage_, intValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "doubleValue",
        .dataTypeSpecific.className = NULL,
        .number = LTSKeyValue_FieldNumber_DoubleValue,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(LTSKeyValue__storage_, doubleValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "boolValue",
        .dataTypeSpecific.className = NULL,
        .number = LTSKeyValue_FieldNumber_BoolValue,
        .hasIndex = -1,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LTSKeyValue class]
                                     rootClass:[LTSCollectorRoot class]
                                          file:LTSCollectorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LTSKeyValue__storage_)
                                         flags:0];
    static const char *oneofs[] = {
      "value",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void LTSKeyValue_ClearValueOneOfCase(LTSKeyValue *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - LTSLog

@implementation LTSLog

@dynamic hasTimestamp, timestamp;
@dynamic keyvaluesArray, keyvaluesArray_Count;

typedef struct LTSLog__storage_ {
  uint32_t _has_storage_[1];
  GPBTimestamp *timestamp;
  NSMutableArray *keyvaluesArray;
} LTSLog__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timestamp",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBTimestamp),
        .number = LTSLog_FieldNumber_Timestamp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LTSLog__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "keyvaluesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(LTSKeyValue),
        .number = LTSLog_FieldNumber_KeyvaluesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LTSLog__storage_, keyvaluesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LTSLog class]
                                     rootClass:[LTSCollectorRoot class]
                                          file:LTSCollectorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LTSLog__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LTSReference

@implementation LTSReference

@dynamic relationship;
@dynamic hasSpanContext, spanContext;

typedef struct LTSReference__storage_ {
  uint32_t _has_storage_[1];
  LTSReference_Relationship relationship;
  LTSSpanContext *spanContext;
} LTSReference__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "relationship",
        .dataTypeSpecific.enumDescFunc = LTSReference_Relationship_EnumDescriptor,
        .number = LTSReference_FieldNumber_Relationship,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LTSReference__storage_, relationship),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "spanContext",
        .dataTypeSpecific.className = GPBStringifySymbol(LTSSpanContext),
        .number = LTSReference_FieldNumber_SpanContext,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LTSReference__storage_, spanContext),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LTSReference class]
                                     rootClass:[LTSCollectorRoot class]
                                          file:LTSCollectorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LTSReference__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t LTSReference_Relationship_RawValue(LTSReference *message) {
  GPBDescriptor *descriptor = [LTSReference descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:LTSReference_FieldNumber_Relationship];
  return GPBGetMessageInt32Field(message, field);
}

void SetLTSReference_Relationship_RawValue(LTSReference *message, int32_t value) {
  GPBDescriptor *descriptor = [LTSReference descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:LTSReference_FieldNumber_Relationship];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum LTSReference_Relationship

GPBEnumDescriptor *LTSReference_Relationship_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "ChildOf\000FollowsFrom\000";
    static const int32_t values[] = {
        LTSReference_Relationship_ChildOf,
        LTSReference_Relationship_FollowsFrom,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(LTSReference_Relationship)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:LTSReference_Relationship_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL LTSReference_Relationship_IsValidValue(int32_t value__) {
  switch (value__) {
    case LTSReference_Relationship_ChildOf:
    case LTSReference_Relationship_FollowsFrom:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - LTSSpan

@implementation LTSSpan

@dynamic hasSpanContext, spanContext;
@dynamic operationName;
@dynamic referencesArray, referencesArray_Count;
@dynamic hasStartTimestamp, startTimestamp;
@dynamic durationMicros;
@dynamic tagsArray, tagsArray_Count;
@dynamic logsArray, logsArray_Count;

typedef struct LTSSpan__storage_ {
  uint32_t _has_storage_[1];
  LTSSpanContext *spanContext;
  NSString *operationName;
  NSMutableArray *referencesArray;
  GPBTimestamp *startTimestamp;
  NSMutableArray *tagsArray;
  NSMutableArray *logsArray;
  uint64_t durationMicros;
} LTSSpan__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "spanContext",
        .dataTypeSpecific.className = GPBStringifySymbol(LTSSpanContext),
        .number = LTSSpan_FieldNumber_SpanContext,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LTSSpan__storage_, spanContext),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "operationName",
        .dataTypeSpecific.className = NULL,
        .number = LTSSpan_FieldNumber_OperationName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LTSSpan__storage_, operationName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "referencesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(LTSReference),
        .number = LTSSpan_FieldNumber_ReferencesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LTSSpan__storage_, referencesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "startTimestamp",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBTimestamp),
        .number = LTSSpan_FieldNumber_StartTimestamp,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LTSSpan__storage_, startTimestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "durationMicros",
        .dataTypeSpecific.className = NULL,
        .number = LTSSpan_FieldNumber_DurationMicros,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LTSSpan__storage_, durationMicros),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "tagsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(LTSKeyValue),
        .number = LTSSpan_FieldNumber_TagsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LTSSpan__storage_, tagsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "logsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(LTSLog),
        .number = LTSSpan_FieldNumber_LogsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LTSSpan__storage_, logsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LTSSpan class]
                                     rootClass:[LTSCollectorRoot class]
                                          file:LTSCollectorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LTSSpan__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LTSTracer

@implementation LTSTracer

@dynamic tracerId;
@dynamic tagsArray, tagsArray_Count;

typedef struct LTSTracer__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *tagsArray;
  uint64_t tracerId;
} LTSTracer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tracerId",
        .dataTypeSpecific.className = NULL,
        .number = LTSTracer_FieldNumber_TracerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LTSTracer__storage_, tracerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "tagsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(LTSKeyValue),
        .number = LTSTracer_FieldNumber_TagsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LTSTracer__storage_, tagsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LTSTracer class]
                                     rootClass:[LTSCollectorRoot class]
                                          file:LTSCollectorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LTSTracer__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LTSMetricsSample

@implementation LTSMetricsSample

@dynamic valueOneOfCase;
@dynamic name;
@dynamic intValue;
@dynamic doubleValue;

typedef struct LTSMetricsSample__storage_ {
  uint32_t _has_storage_[2];
  NSString *name;
  int64_t intValue;
  double doubleValue;
} LTSMetricsSample__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = LTSMetricsSample_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LTSMetricsSample__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "intValue",
        .dataTypeSpecific.className = NULL,
        .number = LTSMetricsSample_FieldNumber_IntValue,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(LTSMetricsSample__storage_, intValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "doubleValue",
        .dataTypeSpecific.className = NULL,
        .number = LTSMetricsSample_FieldNumber_DoubleValue,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(LTSMetricsSample__storage_, doubleValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LTSMetricsSample class]
                                     rootClass:[LTSCollectorRoot class]
                                          file:LTSCollectorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LTSMetricsSample__storage_)
                                         flags:0];
    static const char *oneofs[] = {
      "value",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void LTSMetricsSample_ClearValueOneOfCase(LTSMetricsSample *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - LTSInternalMetrics

@implementation LTSInternalMetrics

@dynamic hasStartTimestamp, startTimestamp;
@dynamic durationMicros;
@dynamic logsArray, logsArray_Count;
@dynamic countsArray, countsArray_Count;
@dynamic gaugesArray, gaugesArray_Count;

typedef struct LTSInternalMetrics__storage_ {
  uint32_t _has_storage_[1];
  GPBTimestamp *startTimestamp;
  NSMutableArray *logsArray;
  NSMutableArray *countsArray;
  NSMutableArray *gaugesArray;
  uint64_t durationMicros;
} LTSInternalMetrics__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "startTimestamp",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBTimestamp),
        .number = LTSInternalMetrics_FieldNumber_StartTimestamp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LTSInternalMetrics__storage_, startTimestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "durationMicros",
        .dataTypeSpecific.className = NULL,
        .number = LTSInternalMetrics_FieldNumber_DurationMicros,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LTSInternalMetrics__storage_, durationMicros),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "logsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(LTSLog),
        .number = LTSInternalMetrics_FieldNumber_LogsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LTSInternalMetrics__storage_, logsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "countsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(LTSMetricsSample),
        .number = LTSInternalMetrics_FieldNumber_CountsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LTSInternalMetrics__storage_, countsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "gaugesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(LTSMetricsSample),
        .number = LTSInternalMetrics_FieldNumber_GaugesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LTSInternalMetrics__storage_, gaugesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LTSInternalMetrics class]
                                     rootClass:[LTSCollectorRoot class]
                                          file:LTSCollectorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LTSInternalMetrics__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LTSAuth

@implementation LTSAuth

@dynamic accessToken;

typedef struct LTSAuth__storage_ {
  uint32_t _has_storage_[1];
  NSString *accessToken;
} LTSAuth__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accessToken",
        .dataTypeSpecific.className = NULL,
        .number = LTSAuth_FieldNumber_AccessToken,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LTSAuth__storage_, accessToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LTSAuth class]
                                     rootClass:[LTSCollectorRoot class]
                                          file:LTSCollectorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LTSAuth__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LTSReportRequest

@implementation LTSReportRequest

@dynamic hasTracer, tracer;
@dynamic hasAuth, auth;
@dynamic spansArray, spansArray_Count;
@dynamic timestampOffsetMicros;
@dynamic hasInternalMetrics, internalMetrics;

typedef struct LTSReportRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t timestampOffsetMicros;
  LTSTracer *tracer;
  LTSAuth *auth;
  NSMutableArray *spansArray;
  LTSInternalMetrics *internalMetrics;
} LTSReportRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tracer",
        .dataTypeSpecific.className = GPBStringifySymbol(LTSTracer),
        .number = LTSReportRequest_FieldNumber_Tracer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LTSReportRequest__storage_, tracer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "auth",
        .dataTypeSpecific.className = GPBStringifySymbol(LTSAuth),
        .number = LTSReportRequest_FieldNumber_Auth,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LTSReportRequest__storage_, auth),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "spansArray",
        .dataTypeSpecific.className = GPBStringifySymbol(LTSSpan),
        .number = LTSReportRequest_FieldNumber_SpansArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LTSReportRequest__storage_, spansArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "timestampOffsetMicros",
        .dataTypeSpecific.className = NULL,
        .number = LTSReportRequest_FieldNumber_TimestampOffsetMicros,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LTSReportRequest__storage_, timestampOffsetMicros),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "internalMetrics",
        .dataTypeSpecific.className = GPBStringifySymbol(LTSInternalMetrics),
        .number = LTSReportRequest_FieldNumber_InternalMetrics,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LTSReportRequest__storage_, internalMetrics),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LTSReportRequest class]
                                     rootClass:[LTSCollectorRoot class]
                                          file:LTSCollectorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LTSReportRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LTSCommand

@implementation LTSCommand

@dynamic disable;

typedef struct LTSCommand__storage_ {
  uint32_t _has_storage_[1];
} LTSCommand__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "disable",
        .dataTypeSpecific.className = NULL,
        .number = LTSCommand_FieldNumber_Disable,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LTSCommand class]
                                     rootClass:[LTSCollectorRoot class]
                                          file:LTSCollectorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LTSCommand__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LTSReportResponse

@implementation LTSReportResponse

@dynamic commandsArray, commandsArray_Count;
@dynamic hasReceiveTimestamp, receiveTimestamp;
@dynamic hasTransmitTimestamp, transmitTimestamp;
@dynamic errorsArray, errorsArray_Count;

typedef struct LTSReportResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *commandsArray;
  GPBTimestamp *receiveTimestamp;
  GPBTimestamp *transmitTimestamp;
  NSMutableArray *errorsArray;
} LTSReportResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "commandsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(LTSCommand),
        .number = LTSReportResponse_FieldNumber_CommandsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LTSReportResponse__storage_, commandsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "receiveTimestamp",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBTimestamp),
        .number = LTSReportResponse_FieldNumber_ReceiveTimestamp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LTSReportResponse__storage_, receiveTimestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transmitTimestamp",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBTimestamp),
        .number = LTSReportResponse_FieldNumber_TransmitTimestamp,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LTSReportResponse__storage_, transmitTimestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "errorsArray",
        .dataTypeSpecific.className = NULL,
        .number = LTSReportResponse_FieldNumber_ErrorsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LTSReportResponse__storage_, errorsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LTSReportResponse class]
                                     rootClass:[LTSCollectorRoot class]
                                          file:LTSCollectorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LTSReportResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
